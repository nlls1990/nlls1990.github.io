---
layout: post
title:  "数据结构之前言"
date:   2016-05-10 23:01:37 +0800
category: C
excerpt: 在开始数据结构之前，先来看看一些小的知识预热一下。主要是计算机内存的分配，指针的风险，以及数组的存储分配。
tags:
- 数据结构
- C语言
---

> 计算机内存分配

首先要清楚的是，在计算机中，并不存在内容的删除，只有内容的覆盖，这也是为什么会有数据恢复这种技术了！

![空闲区与占用区](https://www.z4a.net/images/2017/08/31/data.png)

比如说你在word里编辑你的文件，假如你输入了三个字符，你删除之后，你认为就安全了吗？别人不可能恢复了吗？这样做还是不能销毁你的记录，只有通过更大的内容去覆盖你之前的内容，这样，之前的内容才会被“销毁”。尼玛，真有趣！

值得注意的是，在空闲区也是可能有原始数据的。

在c里 , &表示取地址 , *表示取内容

``` c
int x;
int *p; //这里的*与取内容区分一下，这里是申明p为地址变量，用来存放地址
int **q; //那么这里的q就是存放地址变量的地址
x = 2;
p = &x; //这里将x的地址传给了p这个地址变量，如果此时输出p，将是一个x的地址
q = &p; //这里将p这个地址变量的地址传给了q这个地址变量，如果此时输出q，将是一个p的地址
```

那么*p = x   ，   *q = p  ，    *(*q) = x = 2

> 指针的风险——悬挂式指针

为什么说使用指针是要谨慎，因为一不小心就可能造成系统的崩溃，让我们来看看是怎么回事。

``` c
int *x, *y, a=1, b=2;
int *t;
x = &a;
y = &b;
*t = *x;
*x = *y;
*y = *t;
```

上面这个程序，利用了一个中间变量实现了a,b的数据交换，看似是没有问题的，好像我也是经常这样干！
但是，在内存的分配里我们讲到了空闲区也有可能是有它原本的数据存在的。这里我们假设一下，如果申请的指针变量t原本就是有数据假设为1000，那么我们将a=1暂存到t指针所指向的地址空间，即地址为1000的这个空间，如果说恰好地址为1000的空间又是存放系统文件的，那么不可避免的造成bug、死机甚至是系统的崩溃。

> 数组存取

``` c
int a[9];
```
一个整型占两个字节，这里系统会为这个数组申请18个字节的空间：

![数组存储](https://www.z4a.net/images/2017/08/31/array_storage.png)

而a就是首地址，即：

``` c
*a = a[0]
*(a+2) = a[2] //这里隐含的地址+4
```

而：
``` c
int b[5][5];
```

![二维数组存储](https://www.z4a.net/images/2017/08/31/two_dimensional_array_storage.png)

除b[?][?]表示是具体的数值外，其它表示全为地址

eg：  b+1为b[1]的地址————行地址
b[0]+1为b[0][1]的地址————列地址

``` c
int *p; //列地址
int (*q)[5]; //行地址，这里q+1将会跳5个数据，q相当于b
int *t[5]; //数组指针
```
