---
layout: post
title:  "Android六种核心安全机制"
date:   2016-05-14 20:00:36 +0800
category: Android
excerpt: 深入理解安全机制，Android的六种核心安全机制：加密、密钥、签名与证书。本文为安全机制背景的介绍，以及由需求到技术的革新。
tags:
- Android
- 安全机制
---

> 本文为极客学院“x跨国公”讲师的教学视频观后总结，以便交流分享！（ps：wiki那些东西，看到那些算法的时候真的头大啊！我只能瞻仰瞻仰了）

## __Android安全概述__

### 在典型场景中，安全主要用于解决4类需求：

* 保密（security/confidentiality）
* 鉴别/认证（authentication）
* 完整性（integrity）
* 不可否认性（non-repudiation)

这些需求都是很容易理解的。网络是公开的，现实生活中你可以约到荒山野岭来说出你的隐私的信息，但网络无法做到物理上的隔绝。network is public！这就需要对你的信息进行加密了。

安全领域的潜规则：一个好的密码术是算法公开（经历安全的检验，专家的论证，及黑客若干年的尝试仍未破解）而密钥保密。



## __对称加密__

首先来看看这些名字的定义

* 密钥：分加密密钥，解密密钥
* 明文：没有进行加密，能够直接代表原文含义的信息
* 密文：经过加密处理之后，隐藏原文含义的信息
* 加密：将明文转换成密文的实施过程
* 解密：将密文转换成明文的实施过程

![对称加密](https://www.z4a.net/images/2017/08/31/symmetric_encryption.png)

> 置换加密、转置加密、乘积加密

### 置换变换

顺序不改变，每一个字母（字符/数据）用其他字母（字符/数据）去替换：

![置换变换](https://www.z4a.net/images/2017/08/31/permutation_transformation.png)

### 转置变换

原始信息不变，顺序变换。类似于线性代数里矩阵的转置，将m行n列转换成n行m列，但行列顺序由key决定。

![转置变换](https://www.z4a.net/images/2017/08/31/transpose_transformation.png)

### 乘积变换

例如，将上面信息先进行置换变换再进行转置变换。

以下可以通俗的认为就是置换加密和转置加密迭代的一个应用。

* DES（Data Encryption Standard : 数据加密标准）

但这并不是一个一个字符的变换，而是一个一个块（block），64bit（8个byte）为一个基本加密单元，即：块长度为64位，19道加密工序。

它是一种对称密钥加密块密码算法，但DES现已经不是一种安全的加密方法，主要是因为它使用的56位密钥过短。1999年1月，distributed.net与电子前哨基金会合作，在22小时15分钟内即公开破解了一个DES密钥。在2001年，DES作为一个标准已经被高级加密标准（AES）所替换。另外，DES已经不再作为国家标准科技协会（前国家标准局）的一个标准。

这里密钥表面上是64位，然而只有其中的56位被实际用于算法，其余8位可以被用于奇偶校验，并在算法中被丢弃，因此，DES的有效密钥长度为56位，通常称DES的密钥长度为56位。

关于DES更多详细信息，参见[wiki百科 - DES](https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96)

* AES（Advanced Encryption Standard : 高级加密标准）：

在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一并沿用至今。

严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128 比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度可以是32位的整数倍，以128位为下限，256比特为上限。加密过程中使用的密钥是由Rijndael密钥生成方案产生。

关于AES更多详细信息，参见[wiki百科 - AES](https://zh.wikipedia.org/zh/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86)

这里引出一个问题：对称加密的密钥用什么方式交换呢，明文？肯定是容易被截获的。再用对称加密？那加密密钥的密钥又用什么方式交换呢？这就陷入了死循环，别急，接下来我们就来说说非对称加密。



## __非对称加密__

![非对称加密](https://www.z4a.net/images/2017/08/31/asymmetric_encryption.png)

这里加密密钥为公钥（public key），解密密钥为私钥（private key）。这对密钥由同一个人产生。将公钥公开，私钥自己保管。

公钥算法的理论基石：（数学是科学之基）建立在分解大数的困难度；建立在以大素数为模来计算离散对数的困难度。太过高深，这里不讨论，我也讨论不来。

* RSA加密算法（一种非对称加密算法）

RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。

对极大整数做因数分解的难度决定了RSA算法的可靠性。换言之，对一极大整数做因数分解愈困难，RSA算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用RSA加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。今天只有短的RSA钥匙才可能被强力方式解破（公钥/私钥长度至少1024bit）。到2016年为止，世界上还没有任何可靠的攻击RSA算法的方式。只要其钥匙的长度足够长，用RSA加密的信息实际上是不能被解破的。

具体实现细节可参见wiki百科：[RSA加密算法](https://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95)



## __密钥交换__

对称加密优缺点：

优点：高效；缺点：密钥交换问题，不如RSA的加密安全程度高，但当选择256bit的AES，仍能胜任绝大多数的安全领域。

非对称加密优缺点：

优点：安全性足够高，没有密钥交换问题；缺点：效率低，对于大数据加密很慢。

融合优缺点：

实际的保密会话应用场景：基于高效的对称加密算法对会话进行加密，会话密钥实时产生且周期性变化，基于其他足够安全的方式进行会话密钥的传输和交换。

即：会话用AES  256bit的shared key进行加密，会话密钥产生实时周期变化并由RSA非对称加密进行交换。

> Diffie - Hellman密钥交换协议

基于以大素数为模计算离散对数困难度,双方各自选定key，然后以一定算法变换后传输给对方,双方利用对方交换来的数据和自己选定的key做变换，获得一个一致的结果，作为会话密钥。

![Diffie - Hellman密钥交换协议](https://www.z4a.net/images/2017/08/31/DH_key_exchange_protocol.png)

> 总结：基于对称加密的高效性，会话多用对称加密进行交换，但其shared key存在交换问题，此处用非对称加密或其他交换协议进行交换。



## __消息摘要__

#### HASH与散列函数的定义与特点：

1. HASH（散列）函数（算法）的定义：变长的输入变换成定长的输出。
2. 常见HASH算法：MD5（128bit）、SHA1（160bit）
3. HASH的特点：
* 易变形：即便原始信息发生1bit的变化，HASH的输出将会有不可预知的巨大变化。
* 不可逆：通过HASH结果构造出满足的输入信息是不可能的或者极其困难。

#### 消息摘要和数字指纹：

HASH与指纹的特点类似，数字指纹由此而来。消息摘要的名字很多：HASH、哈希、散列、MD、消息摘要、数字指纹。

#### HASH的应用场景：

1.防篡改：基于易变形特性，以保证完整性。

eg：下载文件时的MD5值（判断是否被篡改或缺失，像迅雷这些下载工具，在下载完成后都会自动的与提供的MD5值进行比对判断）、消息传送时尾部额外传MD。

2.防损坏：与篡改的性质其实是一样的，但这里指非恶意的篡改，所以拿出来讨论。

eg：CRC（32位）校验；MD检验消息恶劣环境传输的完整性和未受损坏；应用程序中对于核心文件/数据库读写的鲁棒性保护，防止掉电和Crash（比如loading到一半时突然掉电或crash，这是文件是损坏不完整的，所以，每次加载完成后都会对HASH进行一次更新，以便进行比对，发现不完整就可进行初始化重新载入）。

3.认证：基于不可逆性，可以认证对端。

eg：HTTP的Digest认证；ppp的CHAP认证；手机登录密码和隐藏MMI的设计（利用HASH避免密码认证过程中的明文传输）。

### HASH应用时遇到的问题：1.在消息尾附带消息摘要（可以篡改内容的同时篡改摘要）2.密码的HASH认证，尽管猜不到你的密码，但可以截获你的HASH，利用这个HASH不断的进行重放攻击。
由此引入了HMAC : Hash - based Message Authentication Code（哈希运算消息认证码）HMAC利用key对原始消息变换后再进行HASH。关于HMAC算法，可参见：[wiki百科 - HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code)；重放攻击，可参见[百度百科 - 重放攻击](http://baike.baidu.com/view/1569933.htm)



## __电子签名__

解决的问题：签名的内容的完整性保护、签名人的不可否认性

公钥密码术的两面性：

1. 在非对称加密中我们知道了利用发布出去的公钥进行信息交流，用自己的私钥进行解密，这是公钥密码术的一面。典型的用于加密。

2. 但是，将其倒置使用，用私钥进行加密（签名人身份的唯一性），发布出去后用公钥进行解密，此典型的应用于电子签名场景，但并非所有公钥密码术都支持，RSA支持。即：RSA和公钥密码术成就了电子签名。

但是，你想象一下，如果你有几个G的小电影要发送给你的基友，你需要对这几个G的小电影进行签名，而RSA是十分的低效（前面讲到过），所以导致不适合于直接对原始信息进行签名。一般的，会先利用HASH先完成消息摘要的完整性鉴别的作用，而后对消息摘要进行基于公钥密码术的签名，签名一般附着于原始消息尾部或头部一起发送。这里总结一下，你接收到消息后，用他的公钥对签名进行解密，如果发现解不开，说明不是你的基友发的，如果解开后，取出MD5值，用原始消息进行HASH与其MD5值进行比对，然后发现了不同，完蛋，被篡改了。这就perfect了吧！



## __证书与PKI__

1. 证书的作用：（现代信任基石）

公钥的存储和交换：公钥作为一个字段存储于数字证书中，证书的交换和传输即可传输/交换公钥

利用签名来保护数字证书本身

![证书](https://www.z4a.net/images/2017/08/31/certificate.png)

数字时代的信任关系：一个受信任者的证书列表

![信任列表](https://www.z4a.net/images/2017/08/31/trusted.png)

2. 证书链和PKI：

数字时代的信任链：证书链


![证书链](https://www.z4a.net/images/2017/08/31/certificate_chain.png)

未受信任的发布者由证书链回溯，逐级验证，找到在受信任列表的发布者，即可信任。

证书签名的不同点：根证书自签名，非根证书父签名

证书的限制：约束、用途、有效期

![约束](https://www.z4a.net/images/2017/08/31/basic_constraint.png)
![用途](https://www.z4a.net/images/2017/08/31/key_usage.png)
![有效期](https://www.z4a.net/images/2017/08/31/term_of_validity.png)

PKI的概念：（Public Key Infrastructure : 公钥基础设施）定义为支持公开密钥管理并能支持认证、加密、完整性和可追究性服务的基础设施。更多信息参见[百度百科 - PKI](http://baike.baidu.com/item/PKI)

3. 基于证书的认证：

基于可信任证书的认证方式被广泛应用在现代安全领域，比如：wifi、https

在https中，典型的client对server的认证和鉴别基于可信任列表
